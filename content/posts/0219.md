---
title: "Notes for episode-0219"
date: 2018-11-26
draft: true
---

# Slow Software
https://www.inkandswitch.com/slow-software.html

- Что знает “медленное” для пользователей?
- “Latency”, а не “пропускная способность”
- Проще всего это проверять на тач-интерфейсах. Дают пользователям две разных программы 1ms vs 70ms и просят сравнить. 70 - однозначно медленно, 1ms - очень быстро, где граница?
- Перетаскивание
- Когда перетаскивают что-то по экрану, пользователи чувствуют, когда latency увеличивается больше 2ms (зависит от человека)
- Рисование
- В Литературе можно найти данные, что приемлимый уровень задержек при рисовании “ручкой” - от 20 до 80мс. По факту, лучше не уходить от 20мс
- Нажатие кнопок
- Уровень чувствительности ~ 70мс
- Понятное дело, ни одна ОС не пытается минимизировать отклик до 1-2мс.
- Печатание
- Уровень чувствительности ~70ms
- Таблица с разными устройствами и задержка печати.
    - Apple IIe 30ms
    - Macbook Pro 2014 100ms
    - Samsung S3 150ms
- Работа с мышью
- Уровень чувствительности ~34ms
- Большой разброс, от единиц ms (хорошее hardware + аккуратное программирование), до >100ms при плохом hw + неправильной работе с буферами io
- Приложения
- Какой правильный ответ про “отзывчивость приложений”?
- Один ответ - типичные “70ms” -> вы будете замечать задержку между нажатием и изменением приложения.
- Сильно зависит от ожиданий пользователей. Никто не ждет, что вы нажмете кнопку, и страница откроется < 70ms
- Google RAIL модель, “<100ms -> immediate result”
- Самая быстрая реакция человека ~220ms, но он еще должен успеть “подумать”
- Авторы думают, что ~100ms - это ок
- Real-world apps
- 1000ms Google поиск - намного быстрее, чем большинство сайтов, но это все равно долго.
- Большинство “встроенных” в ОС приложений < 100ms
- Куча приложений, которые намного хуже 100ms: Slack (о да!)
- Откуда идут задержки
- Устройства ввода
- Клавиатуры
    - Apple magic 15ms
    - Kinesis Freestyle2 30ms
    - Logitech mk360  60ms
- Мыши
    - от 1мс(!)
- “Sample rates” - сканирование входного канала. 60hz -> 17ms
    - iphone 6-8 60hz
    - iphone x 120hz
    - ipad air2, mini4 60hz
    - ipad pro 120hz
    - ipad pro for stylus 240hz
- USB Scanning 125hz -> 1000hz
- Displays
    - frame rate 60hz -> 120hz -> 144hz -> 240hz
    - физическое обновление цвета пикселя единицы - десятки ms
- GPU - частота работы + синхронизация с кодом приложения
- Суммироваться может с наложением проблем
  {{< figure src="/images/0219_1.png" >}}
приложение 15ms, суммарно - 47ms
- Runtime overhead
    - Garbage collection. 10ms - Java / JS, но это весь бюджет отзывчиваости для перетаскивания объектов на touch screen.
    - Scheduling - приложение может не исполняться в этот момент
- Latency by design
    - Концепция “долгого нажатия”
    - Ждать какое-то время, чтобы отсечь “double-tap zoom” (safari)
- Враждебная пользователю задержка - подгрузка рекламы и пр.
- Код приложения - очевидная всем задержка
- Проссумировать все вместе - получается много даже если каждый элемент мал.

# Rebar-3.7.0
https://github.com/erlang/rebar3/releases/tag/3.7.0

- Большой релиз
- Полная переработка работы с Hex пакетами, поддержка нового протокола hex v2, поддержка их новой концепции “private organization”, поддержка локальных зеркал и self-hosted индексов (!)
    - Hex позволяет приватные организации, надо платить деньги!!
- большая переработка системы плагинов вокруг кастомных компиляторов и провайдеров ресурсов
- собирать elixir приложения как зависимости внутри rebar3
- возможность собирать только зависимости (docker images)
- возможность поставить в тест брейкпоинт, чтобы получить repl консоль в точке
- внезапно понял, что большую часть этого релиза делал мой коллега, с которым мы следующий проект будем пилить
